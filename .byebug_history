c
product_sell_params[:sell_by_piece]
c
sell_by_piece
c
result[:average_prices]
sell_by_piece
c
sell_by_piece
c
!product_sell_params[:sell_by_piece].to_i.zero?
c
sell_by_piece
c
product_sell_params[:sell_by_piece].to_i.zero?
c
product_sell_params[:sell_by_piece].to_i.zero?
c
product_sell_params[:sell_by_piece].to_i.zero?
c
product_sell_params[:sell_by_piece]
c
p.errors.messages
p=    Product.create(name: pack.name, size: size, color: color, barcode: pack.barcode, pack: pack)
   13:       name: pack.name, size: size, color: color, barcode: pack.barcode, pack: pack
    Product.create(name: pack.name, size: size, color: color, barcode: pack.barcode, pack: pack)
size
pack.name
c
pack_params['delivery_id']
c
price_in_usd
sell_price
c
rate
sell_price.to_i
c
price_in_usd == price_in_usd_was
c
ProductEntry.last
ProductEntry.where(id:'16')
data[0]
ProductEntry.find_by("16")
c
price_in_usd
average_prices["average_buy_price_in_uzs"]
price_in_usd
sell_price
c
ProductSell.last
price_data
c
data[1]["amount"]
data[0]
data[1]["amount"]
c
amount <= pack.initial_remaining
c
product_sell.sell_price
price_in_usd
sell_price
c
sell_price
c
sell_price
c
sell_price.to_i
c
sell_price
c
price_in_usd_was
c
sell_price
price_in_usd
c
price_data
average_prices
c
!new_record?
self.persisted?
c
average_prices
c
sell_price_in_uzs
self.total_profit
c
sell_price_in_uzs
buy_price_in_uzs
buy_price_in_usd
sell_price_in_usd
c
average_sell_price_in_usd
c
price_in_usd
average_sell_price_in_usd
c
price_data
average_sell_price_in_uzs
average_buy_price_in_uzs
average_buy_price_in_usd
average_sell_price_in_usd
c
set_prices_in_usd
rate
price_data.to_h
c
price_data.to_h
c
set_prices_in_usd
price_data.to_h
c
price_data.to_h
a
a.result
      a=ProductSells::FindAverageSellAndBuyPrice.run!(price_data: price_data.to_h, rate: rate, price_in_usd: set_prices_in_usd)
set_prices_in_usd
price_data.to_h
c
price_data.to_h
c
price_data.to_h
c
price_data.to_h
c
set_prices_in_usd != product_entry.paid_in_usd
set_prices_in_usd
c
price_data.to_h
c
ProductEntry.find(13)
amount
product_entry_ids
c
unsold_product_entries
amount
pack
c
response.result
c
pack
        response = ProductSells::FindProductEntriesUntilAmount.run!(product: pack,          amount: amount)
pack.class
c
first_available_entry
pack.initial_remaining <= 0 && !first_available_entry.nil?
!first_available_entry.nil?
pack.initial_remaining
c
pack
c
response.result[:average_prices][:average_buy_price_in_uzs].to_i/12000
CurrencyRate.last.rate
response.result
c
response.result
c
response.result
c
response.errors.messages
response.result
c
@filtered_packs
c
Pack.last
c
@product.errors.messages
c
dog_attributes.values.any?(&:empty?)
dog_attributes.keys
c
dog_attributes.values.any?(&:empty?)
dog_attributes
c
dog_attributes
c
dog_attributes
c
dog_attributes
dog_attributes[:size_id] = 3
dog_attributes
c
params.require(:pack)
 params.require(:pack).permit(:name)
c
User.last
reload!
product_category_id
Product.exists?(code: code)
Product.exists?(code: code) && Product.where(code: code).pluck(:product_category_id).uniq.size > 1
c
diff
      diff = debt_operations.price_in_usd.отдача.sum(:price) - debt_operations.price_in_usd.приём.sum(:price)
debt_operations.price_in_uzs.приём.sum(:price)
debt_operations.price_in_uzs.отдача.sum(:price)
debt_operations.price_in_uzs.приём.sum(:price)
c
debt_operations.price_in_usd.приём.sum(:price)
debt_operations.price_in_uzs.отдача.sum(:price)
in_usd
debt_operations.price_in_usd.отдача.sum(:price)
c
created_at.beginning_of_day
c
anchor
c
first_record
c
delivery_from_counterparty
!sale.nil?
first_record
c
params[:new_income][:price]
c
params[:new_income][:price]
c
params[:new_income][:price]
params[:price]
c
params[:price].to_i <= 0
params[:price]
continue
@transaction_history
continue
@expenditure
continue
user.name.join
user.email
user.errors.messages
continue
User.last.email
continue
User.last.email
continue
User.last.email
continue
User.last.email
params[:user][:passwords]
params[:name]
params[:password]
continue
params.dig(:q, :date).blank?
continue
outcomer_params['role']
continue
quantity
product_id
index
continue
index
continue
new_hash.to_h
product_id
index
quantity
index
product_id
